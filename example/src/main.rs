use std::marker::PhantomData;

use futures::executor::block_on_stream;

// Message Proc Macro crate
struct MessageSpec {
    response_type: &'static str,
    is_async: bool,
    name: &'static str,
}

trait Message {
    type Response;

    fn name() -> &'static str;
}

// Message Crate
#[derive(Message)]
#[pt_response(i32)]
struct Add1 {
    x: i32
}

#[derive(Message)]
#[pt_async]
#[pt_response(i32)]
struct Times3 {
    x: i32
}

#[derive(Message)]
struct Unimplemented {}

// Generates

impl Message for Add1 {
    type Response = i32;

    fn name() -> &'static str {
        concat!(module_path!(), "::Add1")
    }
}

impl Message for Times3 {
    type Response = i32;
    
    fn name() -> &'static str {
        concat!(module_path!(), "::Times3")
    }
}

// !Generates

// Ctx trait proc macro crate

#[proc_macro]
pub fn generate_agents_proc_macro_crate(_item: TokenStream) -> TokenStream {}

// Agents proc macro crate (partially generated by above)
enum AnyMessage {
    Add1(Add1, oneshot::channel::Sender<<Add1 as Message>::Response>),
    Times3(Times3, oneshot::channel::Sender<<Times3 as Message>::Response>),
    Unimplemented(Unimplemented, oneshot::channel::Sender<<Unimplemented as Message>::Response>),
    Stop(i32),
}

trait Agent {
    fn handled_message_ids() -> &'static[&'static str];
}

trait CanHandle<T: Message> {
    const CAN_HANDLE: bool;
}

trait Handle<T: Message>: CanHandle<T> {
    fn handle(&self, message: &T) -> T::Response;
}

trait AsyncHandle<T: Message>: CanHandle<T> {
    fn async_handle<'a>(&'a self, message: &T) -> BoxFuture<'a, T::Response>;
}

trait CtxProxy: AsyncHandle<Add1> + AsyncHandle<Times3> + AsyncHandle<Unimplemented> + CanHandle<Add1> + ... {
    fn get_proxy(&self) -> Box<CtxProxy>;
}
trait Ctx:      Handle<Add1>      + Handle<Times3>      + Handle<Unimplemented>      + CanHandle<Add1> + ... {
    fn get_proxy(&self) -> Box<CtxProxy>;
}

struct AssertCanHandle<C: CanHandle<M>, M: Message> {
    p1: PhantomData<C>,
    p2: PhantomData<M>,
}

impl<C: CanHandle<M>, M: Message> AssertCanHandle<C, M> {
    const VALUE: () = assert!(<C as CanHandle<M>>::CAN_HANDLE);
}

fn assert_can_handle<C: CanHandle<M>, M: Message>(_c: &C, _m: &M) {
    let _: () = AssertCanHandle::<C, M>::VALUE;
}

macro_rules! call {
    ($ctx: expr, $msg: expr) => {
        {
            let c = $ctx;
            let m = $msg;
            assert_can_handle(c, &m);
            c.handle(&m)
        }
    }
}

pub fn impl_agent(item: TokenStream) -> TokenStream {
    // iterate through items
}


// Agents Crate
struct MathsAgent {
}

impl_agent! MathsAgent {
    request Add1 {
        m.x + 1
    }
    
    request Times3 {
        m.x * 3
    }
}

// generates

impl Agent for MathsAgent {
    fn handled_message_ids() -> &'static[i32] {
        [
            <Add1 as Message>::name(),
            <Times3 as Message>::name(),
        ]
    }
}

impl Agent {
    fn handle1(&self, ctx: &Ctx, msg: &Add1) -> <Add1 as Message>::Response {
        const _: () = assert!(<Add1 as Message>::IS_REQUEST);
        const _: () = assert!(!<Add1 as Message>::IS_ASYNC);

        msg.x + 1
    }

    fn handle2<'a, 'b>(&'a self, ctx: &'b Ctx, msg: Times3) -> BoxFuture<'b, <Add1 as Message>::Response>
    where 'a: 'b {
        const _: () = assert!(<Add1 as Message>::IS_REQUEST);
        const _: () = assert!(<Add1 as Message>::IS_ASYNC);

        async {
            msg.x * 3
        }
    }
}

// !generates


// Make Context Crate




// Make Context proc macro
#[proc_macro]
pub fn make_application(item: TokenStream) -> TokenStream {...} 


// generates
#[derive(Clone)]
struct ContextProxy {
    sender: futures::channel::mpsc::Sender<AnyMessage>,
}

struct Context<'a> {
    maths_agent: &'a MathsAgent,
    proxy: ContextProxy,
}

impl CanHandle<Add1> for Context {const CAN_HANDLE: bool = true;}
impl CanHandle<Times3> for Context {const CAN_HANDLE: bool = true;}
impl CanHandle<Unimplemented> for Context {const CAN_HANDLE: bool = false;}

impl CanHandle<Add1> for ContextProxy {const CAN_HANDLE: bool = true;}
impl CanHandle<Times3> for ContextProxy {const CAN_HANDLE: bool = true;}
impl CanHandle<Unimplemented> for ContextProxy {const CAN_HANDLE: bool = false;}

impl Handle<Add1> for Context {
    fn handle(&self, m: &Add1) -> <Add1 as Message>::Response {
        self.maths_agent.handle1(self, m)
    }
}

impl Handle<Times3> for Context {
    fn handle<'a>(&'a self, m: Times3) -> BoxFuture<'a, <Times3 as Message>::Response> {
        self.maths_agent.handle2(self, m)
    }
}

impl Handle<Unimplemented> for Context {
    fn handle(&self, _m: &Unimplemented) -> <Unimplemented as Message>::Response {
        panic!();
    }
}

// and for the other messages
impl AsyncHandle<Add1> for ContextProxy {
    fn async_handle<'a>(&'a self, msg: Add1) -> BoxFuture<'static, <Add1 as Message>::Response> {
        let (sender, receiver) = oneshot::channel::oneshot::channel::<<Add1 as Message>::Response>();
        self.sender.send(AnyMessage::Add1(msg, sender));
        receiver.boxed()
    }
}

struct Application {
    maths_agent: Option<MathsAgent>,
}

impl Application {
    pub fn new() -> Self {
        // go through agents that need initialising
        // have mechanism to create contexts which know which requests they can handle
        // at each point in the initialisation
    }

    pub fn run(self, stop_receiver: oneshot::Receiver<()>) -> i32 {
        let (sender, receiver) = mpsc::channel::<AnyMessage>();

        let context = Context{maths_agent: &self.maths_agent, proxy: ContextProxy{sender}};

        let stop = Cell::new(None);
        let executor = smol::LocalExecutor::new();

        let new_task_spawner = executor.spawn(async {
            let next_task = receiver.next().await;
            match next_task {
                Stop(i) => {
                    stop.set(Some(i));
                },
                Add1(msg, ret_sender) => {
                    executor.spawn(async move {
                        ret_sender.send(context.handle(msg));
                    });
                },
                Times3(msg, ret_sender) => {
                    executor.spawn(async move {
                        ret_sender.send(context.handle(msg).await);
                    });
                },
                ...
            }
        });

        loop {
            match stop.get() {
                None => {
                    block_on(executor.tick());
                }
                Some(i) => {
                    return i;
                }
            }
        }
    }
}

impl Drop for Application {
    fn drop(self) {
        // go backwards through all handlers calling de_init or something
    }
}


impl Ctx for Context {
    fn get_proxy(&self) -> Box<CtxProxy> {
        Box::new(self.proxy.clone())
    }
}

// !generates


fn main() {
    let appliation = make_application!(
        MathsAgent,
    );
    appliation.run();
}
